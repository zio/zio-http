---
id: digest-authentication
title: "Securing Your APIs: Digest Authentication"
---
# Digest Authentication

Digest Authentication is a more secure HTTP authentication method than Basic Authentication, designed to address the security vulnerabilities of transmitting credentials in easily decodable formats. In this guide, we'll explore how to implement Digest Authentication using ZIO HTTP, providing both server-side middleware and client-side integration.

## Understanding Digest Authentication

Digest Authentication, defined in RFC 2617 and extended in RFC 7616, is an HTTP authentication scheme that uses a **challenge-response mechanism with cryptographic hashing**. Unlike Basic Authentication, which transmits credentials in Base64 encoding, Digest Authentication never sends the actual raw password over the network. Instead, it uses hash functions to create a digest (typically MD5 or SHA-256) that proves the client knows the password without revealing it.

### The Challenge-Response Flow

The authentication process follows this sequence:

1. **Initial Request**: Client makes a request to a protected resource
2. **Challenge**: Server responds with `401 Unauthorized` and a `WWW-Authenticate` header containing:
    - `realm`: A string indicating the protection space
    - `nonce`: A server-generated unique value (prevents replay attacks)
    - `qop`: Quality of Protection (usually "auth")
    - `algorithm`: Hash algorithm to use (MD5, SHA-256, etc.)
3. **Response**: Client computes a digest using the provided parameters and its credentials, then retries the request with an `Authorization` header
4. **Verification**: Server validates the digest and grants or denies access

Here is an example of the initial request, the challenge response from the server, and the subsequent authenticated request:

1. First, client tries to access a protected resource on /profile/me without authentication: 

```http
GET /profile/me HTTP/1.1
Host: localhost:8080
```

2. The server responds with "401 Unauthorized" and a challenge:

```http
HTTP/1.1 401 Unauthorized
content-length: 0
date: Thu, 24 Jul 2025 07:27:40 GMT
www-authenticate: Digest realm="User Profile", nonce="MTc1MzM0MjA2MDI0NDpmbXNGK2dTblF4WEVwN1gwWktMVllRPT0=", opaque="uSla+F7cMBsB/t3K9OCLzg==", stale=false, algorithm=MD5, qop="auth", charset=UTF-8, userhash=false
```

This challenge says to the client that you are trying to access a protected resource in the "User Profile" realm, and you need to provide a valid digest which is generated using the provided parameters (`realm`, `nonce`, `algorithm`, etc.) and your credentials (username and password).

Please note that the challenge is sent by server in the `WWW-Authenticate` header, which is part of the HTTP response. 
- The `nonce` is a unique value generated by the server, and it changes for each authentication challenge to prevent replay attacks.
- The `realm` is a string that identifies the protected area, and it is used to group resources that require the same authentication behavior.
- The `algorithm` specifies the hashing algorithm the client should use to compute the digest. 
- The `qop` (Quality of Protection) specifies the protection level, such as "auth" for authentication or "auth-int" for authentication with integrity protection.

3. The client computes the digest, using the provided parameters and user's credentials. To compute the digest, the client uses the following formula:

```http
HA1 = H(username:realm:password)
HA2 = H(method:uri)
response = H(HA1:nonce:nc:cnonce:qop:HA2)
```

Let's explain each parameter in the formula:

- `username`: The username of the user trying to authenticate
- `realm`: The protection space, a string that identifies the protected area. This is provided by the server in the challenge in previous step.
- `password`: The password of the user trying to authenticate
- `method` and `uri`: The HTTP method and requested URI. These are used to ensure the digest is specific to the request being made, making request tampering attacks more difficult, as the digest is tied to the specific method and URI.
- `nonce`: A server-generated unique value that changes for each authentication challenge. It prevents replay attacks by ensuring each authentication exchange is unique.
- `nc` (nonce count): A hexadecimal counter that increments with each request using the same nonce. This allows the server to detect if requests are being replayed or received out of order. It is useful for defending against replay attacks. Assume attacker intercepts a very important request and tries to replay it later, the server can detect that the nonce count has already been used and reject the request.
- `cnonce` (client nonce): A random value generated by the client, adding entropy from the client side and providing mutual authentication benefits.
- `qop` (quality of protection): Specifies the protection level, such as "auth" for authentication or "auth-int" for authentication with integrity protection.

This digest calculation cryptographically makes it impossible for an attacker to use hashed credentials that would work elsewhere. It provides several security improvements over basic authentication:

1. **Password Protection**: The actual password is never transmitted over the network
2. **Replay Attack Mitigation**: The nonce prevents replay of captured requests. If two requests are made with the same nonce, the server can detect the replay attempt.
3. **Mutual Authentication**: Both client and server can verify each other's identity
4. **Integrity Protection**: The digest includes the HTTP method and URI, preventing request tampering attacks. Also, if the `qop` is set to `auth-int`, it includes the request body hash, ensuring the integrity of the request content.

However, with these security improvements, it's still necessary to use HTTPS for complete security, as Digest Authentication doesn't encrypt the entire communication channel.

Let's calculate the digest response using the formula above:

```
HA1 = H(username:realm:password)
= MD5(john:User Profile:password123)
= e858d07c1afb2c75ea1f1ee29c1d7702

HA2 = H(method:uri)
= MD5(GET:/profile/me)
= 509ae9f341ffefdd68447afcdae1e7bf

nonce  =  MTc1MzM0MjA2MDI0NDpmbXNGK2dTblF4WEVwN1gwWktMVllRPT0= // server-generated nonce
nc     = 00000001 // server-generated nonce count (hexadecimal)
qop    = auth
cnonce = 71n315lg67i4kr9473e5hw // client-generated nonce

response = H(HA1:nonce:nc:cnonce:qop:HA2)
= MD5(e858d07c1afb2c75ea1f1ee29c1d7702:MTc1MzM0MjA2MDI0NDpmbXNGK2dTblF4WEVwN1gwWktMVllRPT0:00000001:71n315lg67i4kr9473e5hw:auth:509ae9f341ffefdd68447afcdae1e7bf)
= f7e07fe43aa7a7e3a296edf8f3b3772a
```

After calculating the digest response, the client constructs the `Authorization` header with the computed values:

```http
GET /profile/me HTTP/1.1
Host: localhost:8080
Authorization: Digest username="john", realm="User Profile", nonce="MTc1MzM0MjA2MDI0NDpmbXNGK2dTblF4WEVwN1gwWktMVllRPT0=", uri="/profile/me", algorithm="MD5", qop="auth", nc="00000001", cnonce="71n315lg67i4kr9473e5hw", response="f7e07fe43aa7a7e3a296edf8f3b3772a", userhash=false, opaque="uSla+F7cMBsB/t3K9OCLzg=="
```

4. The server verifies the digest by recalculating it using the same parameters and its stored credentials for the user "john". If the digest matches, the server grants access to the requested resource. To do this, the server extracts the "username" parameter from the authorization header, then looks up the user's password in its database, now it can compute the digest using the same algorithm and parameters as the client. If the digest matches the one sent by the client, the server responds with the requested resource:

```http
HTTP/1.1 200 Ok
content-length: 76
content-type: text/plain
date: Wed, 23 Jul 2025 12:59:32 GMT

Hello john! This is your profile: 
 Username: john 
 Email: john@example.com
```

If the digest does not match, the server responds with `401 Unauthorized` again, indicating that the authentication failed with a new `WWW-Authenticate` header containing a new challenge.


## Implementing Digest Authentication

To implement Digest Authentication in ZIO HTTP, we are going to create a middleware that intercepts incoming requests, checks for the presence of the `Authorization` header, and validates the digest against stored user credentials. We'll also create a simple HTML client to demonstrate how to use Digest Authentication in practice.

ZIO HTTP currently does not have built-in support for Digest Authentication, but it has an excellent foundation for implementing it as a custom middleware.

### Overview

The middleware we are going to implement should handle the two main scenarios:

1. Check if the request contains an `Authorization` header. 
   - If it is present and of type `Header.Authorization.Digest`, it means the client is trying to authenticate by responding to a challenge from the server. So we need to validate the digest against the stored user credentials.
     - If the digest is valid, we allow the request to proceed.
     - If the digest is invalid, we respond with a `401 Unauthorized` status and a new challenge in the `WWW-Authenticate` header.
   - Otherwise, if the header is not present, this means the client is trying to access a protected resource without authentication, so we need to respond with a `401 Unauthorized` status and a `WWW-Authenticate` header containing the challenge parameters (realm, nonce, algorithm, etc.).

```scala
val digestAuthHandler: HandlerAspect[Any, Unit] =
   HandlerAspect.interceptIncomingHandler[Any, Unit] {
      Handler.fromFunctionZIO[Request](request =>
         request.header(Header.Authorization) match {
            // If the request contains a Digest Authorization header
            case Some(authHeader: Header.Authorization.Digest) =>
               // 1. find the user's credentials in the database using the username from the header
               // 2. validate the digest against stored user credentials
               // 3. if valid, allow the request to proceed
               // 4. if invalid, respond with 401 Unauthorized with a new challenge
   
            // No auth header or not digest, send challenge
            case _ =>
             // 1. respond with 401 Unauthorized with a new challenge
         },
      )
   }
```

### Digest Authentication Service

There are two main operations we need to implement:

   - **Creating a challenge**: When the client tries to access a protected resource without authentication, we need to generate a challenge that includes the realm, nonce, algorithm, and quality of protection (qop). The server generates the challenge and sends it back to the client in the `WWW-Authenticate` header of the response.
   - **Validating the response**: When the client responds with a digest in the `Authorization` header, the server needs to validate it against the stored user credentials. This involves computing the expected digest and comparing it with the one sent by the client.

It is good to put these functionalities into a separate service called `DigestAuthService`:

```scala
trait DigestAuthService {
   def generateChallenge(
     realm: String,
     qop: List[QualityOfProtection],
     algorithm: HashAlgorithm
   ): UIO[DigestChallenge]

   def validateResponse(
     digest: DigestResponse,
     password: Secret,
     method: Method,
     body: Option[String] = None,
   ): ZIO[Any, DigestAuthError, Boolean]
}
```

The `createChallenge` method generates a new challenge with the specified realm, quality of protection, and algorithm. The `validateResponse` method checks if the provided digest response is valid for the given password, HTTP method, and optionally the request body.

#### Generating a Challenge

As mentioned earlier, the formula for generating the challenge is:

```
HA1 = H(username:realm:password)
HA2 = H(method:uri)
response = H(HA1:nonce:nc:cnonce:qop:HA2)
```

#### Nonce Management Service

The important aspect of the challenge generation is the `nonce` generation. The `nonce` is a unique value generated by the server for each challenge, which prevents replay attacks and ensures freshness in the authentication process. It should be a random value that changes for each request/session, so that reuse (replay) of old requests is not possible.

There is no mandated algorithm for nonce generation, but here are some common approaches:

- **Random Nonce**: The nonce can be a random value generated by the server. This is a simple approach but requires the server to keep track of used nonces to prevent replay attacks. After receiving back the response to a challenge, if the digest is valid, the server should mark the nonce as used, so it cannot be reused in subsequent requests. With this approach the server do not use the nonce count (`nc`), as the nonce itself is unique for api session and cannot be reused:

```scala
val nonce = 
  Random.nextBytes(16)
    .map(_.toArray)
    .map(Base64.getEncoder.encodeToString) 
// e.g. nonce: pY0+z+EeTgrXwq/Y3L8lGA==
```

- **Timestamp-based Nonce**: The nonce can be a combination of the current timestamp and a random value or hash of the timestamp. This allows the server to check if a nonce is too old and reject it, reducing the window of the session for replay attacks. After receiving back the response to a challenge, if the digest is valid, the server should first check if the nonce is still valid (not expired) and then mark the combination of `nonce` and `nc` as used, so it cannot be reused in subsequent requests. The next request with the same nonce should increment the `nc` value to indicate that it is a new request. Using this approach, we can use the same nonce for multiple requests until the window of the session expires.

To implement these functionalities, we are going to create a `NonceService` that will handle nonce generation, validation, tracking of used nonces:

```scala
trait NonceService {
  def generateNonce(timestamp: Long): UIO[String]
  def validateNonce(nonce: String, maxAge: Duration): UIO[Boolean]
  def isNonceUsed(nonce: String, nc: String): UIO[Boolean]
  def markNonceUsed(nonce: String, nc: String): UIO[Unit]
}
```

Let's start by implementing the `generateNonce` method:

```scala
final case class NonceServiceLive(
  secretKey: Secret
) extends NonceService {
  private def computeHash(timestamp: Long, secretKey: Secret): Array[Byte] = {
    val mac = Mac.getInstance("HmacSHA256")
    mac.init(new SecretKeySpec(secretKey.stringValue.getBytes("UTF-8"), "HMAC-SHA256"))
    mac.doFinal(timestamp.toString.getBytes("UTF-8"))
  }

  def generateNonce(timestamp: Long): UIO[String] =
    ZIO.succeed {
      // only the sever knows the secret key
      val hashBytes = Array.copyOf(computeHash(timestamp, secretKey), 16)
      val base64Hash = Base64.getEncoder.encodeToString(hashBytes)

      Base64.getEncoder.encodeToString(s"$timestamp:$base64Hash".getBytes("UTF-8"))
    }
}
```

Each nonce generated by this method has two parts: 

```
nonce = Base64(timestamp:Base64(KD(timestamp)))
```

The `timestamp` is the current time in milliseconds, and `KD(timestamp)` is the HMAC hash of the timestamp using a secret key known only to the server. The nonce is then Base64-encoded to ensure it can be safely transmitted in HTTP headers.

When receiving nonce from the client, the server should decode it, extract the timestamp and hash, chek if the nonce is valid:
    — First check if the timestamp is within an acceptable range (e.g., not older than a certain duration, like 5 minutes). This prevents replay attacks by ensuring that the nonce is fresh.
    — Then, verify that the hash matches the computed hash for the given timestamp using the same secret key. This allows the server to ensure that the nonce was generated by the server and has not been tampered with.

Let's implement the `validateNonce` method to check if the nonce is valid:

```scala
final case class NonceServiceLive(secretKey: Secret) extends NonceService {
  private def computeHash(timestamp: Long, secretKey: Secret): Array[Byte] = ???
    
  def generateNonce(timestamp: Long): UIO[String] = ???

  def validateNonce(nonce: String, maxAge: Duration): UIO[Boolean] =
    ZIO.succeed {
      try {
        val decoded = new String(Base64.getDecoder.decode(nonce), "UTF-8")
        val parts = decoded.split(":", 2)

        if (parts.length != 2) {
          false
        } else {
          val providedHashHex = parts(1)
          val timestamp = parts(0).toLong

          // Verify timestamp is within allowed age
          val now = java.lang.System.currentTimeMillis()
          val isTimestampValid = (now - timestamp) <= maxAge.toMillis

          if (!isTimestampValid) {
            false
          } else {
            val expectedHashBytes =
              computeHash(timestamp, secretKey)

            // Convert provided hash back to bytes for constant-time comparison
            constantTimeEquals(expectedHashBytes, Base64.getDecoder.decode(providedHashHex))
          }
        }
      } catch {
        case _: Exception => false
      }
    }
}
```

After validating the nonce, before we proceed to validate the digest response, we should also check if the nonce has already been used in a previous request. This can be done by maintaining a map of used nonces and their associated counts (`nc`). If the nonce is found in the set, it means it has already been used, and we should reject the request:

```scala
final case class NonceServiceLive(
    usedNonce: Ref[Map[String, Set[String]]],
    secretKey: SecretKey
  ) extends NonceService {
  def generateNonce(timestamp: Long): UIO[String] = ???

  def validateNonce(nonce: String, maxAge: Duration): UIO[Boolean] = ???
  
  def isNonceUsed(nonce: String, nc: String): UIO[Boolean] =
    usedNonce.get.map(_.get(nonce).exists(_.contains(nc)))
}
```

Similarly, we have to implement the `markNonceUsed` method to mark a nonce as used after a successful authentication:

```scala
final case class NonceServiceLive(
    usedNonce: Ref[Map[String, Set[String]]],
    secretKey: SecretKey
  ) extends NonceService {
  def generateNonce(timestamp: Long): UIO[String] = ???
  
  def validateNonce(nonce: String, maxAge: Duration): UIO[Boolean] = ???
  
  def isNonceUsed(nonce: String, nc: String): UIO[Boolean] =
    usedNonce.get.map(_.get(nonce).exists(_.contains(nc)))
    
  def markNonceUsed(nonce: String, nc: String): UIO[Unit] =
    usedNonce.update { nonces =>
      val existing = nonces.getOrElse(nonce, Set.empty)
      nonces.updated(nonce, existing + nc)
    }
}
```

#### Session Algorithms

This formula is the simplest version of the digest calculation when the picked algorithm is regular, e.g. `MD5`, `SHA-256`, but when the user picked the session algorithms, those ending with "-sess", e.g. `MD5-sess`, `SHA-256-sess`, the `HA1` would be as follows:

```
If algorithm ends in "-sess":
    HA1 = H(H(username:realm:password):nonce:cnonce)
otherwise:
    HA1 = H(username:realm:password)
```

In regular algorithms, the `HA1` is a constant value for a given `username`, `realm`, and `password`. This means that if an attacker captures the `HA1` value, they can use it to generate valid digests for any request made by that user.

The session algorithms are variants of a digest algorithm that enhance security by making the hash depend not only on the `username`, `realm`, and `password` but also on values that are unique to each session, such as the server nonce (`nonce`) and the client nonce (`cnonce`).

If someone steals `H(username:realm:password)` from the client, e.g., via sniffing or memory dump, they still can't generate a valid digest without knowing the specific `nonce` and `cnonce` values.

So, as security best practices, always prefer `-sess` algorithms, if both the client and server support them, especially over unsecured networks.


Please note that `DigestChallenge` and `DigestResponse` are custom data types that encapsulate the digest challenge parameters and the digest response, respectively. They has the same structure as `Header.WWWAuthenticate.Digest` and `Header.Authorization.Digest`, but with more type safety guarantees.


To validate the digest header, we also should pass the password and method of the request, and optionally the body if we want to validate the integrity of the request body as well. Integrity of the request body is only required if the `qop` is set to `auth-int`, which means that the request body has been included in the digest calculation.



### User Service

Beside the `DigestAuthService`, we also need a `UserService` to store and retrieve user credentials. This service will provide methods to authenticate users and retrieve their passwords:

```scala
import zio._
import zio.Config._

case class User(username: String, password: Secret, email: String)

trait UserService {
   def getUser(username: String): Task[Option[User]]
   def addUser(user: User): Task[Unit]
   def updateEmail(username: String, newEmail: String): Task[Unit]
}
```

For the sake of simplicity, we can use an in-memory store for users, but in a real application, you would typically use a database or another persistent storage solution:

```scala
case class UserServiceLive(users: Ref[Map[String, User]]) extends UserService {
   def getUser(username: String): Task[Option[User]] =
      users.get.map(_.get(username))

   def addUser(user: User): Task[Unit] =
      users.update(_.updated(user.username, user))

   def updateEmail(username: String, newEmail: String): Task[Unit] =
      users.update { currentUsers =>
         currentUsers.get(username) match {
            case Some(user) => currentUsers.updated(username, user.copy(email = newEmail))
            case None       => currentUsers // No change if user not found
         }
      }
}

object UserService {
   private val initialUsers = Map(
      "john"  -> User("john", Secret("password123"), "john@example.com"),
      "jane"  -> User("jane", Secret("secret456"), "jane@example.com"),
      "admin" -> User("admin", Secret("admin123"), "admin@company.com"),
   )

   val live: ZLayer[Any, Nothing, UserService] =
      ZLayer.fromZIO(Ref.make(initialUsers).map(UserServiceLive(_)))
}
```

### Implementing the Middleware

The middleware uses the `UserService` to retrieve user credentials to be able to validate the digest. We can make our middleware more flexible by passing the user details to the outgoing request context in case of success of validation, so that downstream handlers can access the authenticated user information:

```scala
object DigestAuthHandlerAspect {
  def apply(
    realm: String,
  ): HandlerAspect[DigestAuthService & UserService, User] =
    HandlerAspect.interceptIncomingHandler[DigestAuthService & UserService, User] {
      handler { (request: Request) =>
        request.header(Header.Authorization) match {
          case Some(digest: Header.Authorization.Digest) =>
            for {
              user <-
                ZIO
                  .serviceWithZIO[UserService](_.getUser(digest.username))
                  .some
                  .orElse(unauthorizedResponse(s"Failed to authenticate user ${digest.username}"))
              body    <- request.body.asString.option
              result  <- ZIO
                .serviceWithZIO[DigestAuthService](
                  _.validateDigest(digest, user.password, request.method, body),
                )
                .flatMap {
                  case true  =>
                    ZIO.succeed((request, user))
                  case false =>
                    unauthorizedResponse(s"Invalid digest response for user ${digest.username}.")
                }
            } yield result

          case _ =>
            // No auth header or not digest, send challenges
            unauthorizedResponse(s"Missing Authorization header for realm: $realm")
        }
      }
    }
}
```






To decode and extract the digest parameters from incoming request, we do not require any extra effort, as ZIO HTTP extracts the `Authorization` header and is accessible via `request.header(Header.Authorization)` header. If the header is present, we can check if it is of type `Header.Authorization.Digest`, which contains all the necessary parameters for digest authentication.




