---
id: digest-authentication
title: "Securing Your APIs: Digest Authentication"
---

# Digest Authentication

Digest Authentication is a more secure HTTP authentication method than Basic Authentication, designed to address the security vulnerabilities of transmitting credentials in easily decodable formats. In this guide, we'll explore how to implement Digest Authentication using ZIO HTTP, providing both server-side middleware and client-side integration.

## Understanding Digest Authentication

Digest Authentication, defined in RFC 2617, is an HTTP authentication scheme that uses a **challenge-response mechanism with cryptographic hashing**. Unlike Basic Authentication, which transmits credentials in Base64 encoding, Digest Authentication never sends the actual password over the network. Instead, it uses hash functions to create a digest (typically MD5 or SHA-256) that proves the client knows the password without revealing it.

### The Challenge-Response Flow

The authentication process follows this sequence:

1. **Initial Request**: Client makes a request to a protected resource
2. **Challenge**: Server responds with `401 Unauthorized` and a `WWW-Authenticate` header containing:
    - `realm`: A string indicating the protection space
    - `nonce`: A server-generated unique value (prevents replay attacks)
    - `qop`: Quality of Protection (usually "auth")
    - `algorithm`: Hash algorithm to use (MD5, SHA-256, etc.)
3. **Response**: Client computes a digest using the provided parameters and its credentials, then retries the request with an `Authorization` header
4. **Verification**: Server validates the digest and grants or denies access

### Digest Calculation

The digest is calculated using a simple algorithm as follows:

```
HA1 = MD5(username:realm:password)
HA2 = MD5(method:uri)
response = MD5(HA1:nonce:nc:cnonce:qop:HA2)
```

- **nonce**: A **server**-generated random value that changes for each authentication challenge. It prevents replay attacks by ensuring each authentication exchange is unique.
- **nc (nonce count)**: A hexadecimal counter that increments with each request using the same nonce. This allows the server to detect if requests are being replayed or received out of order. It is useful for defending against replay attacks. Assume attacker intercepts a very important request and tries to replay it later, the server can detect that the nonce count has already been used and reject the request.
- **cnonce (client nonce)**: A random value generated by the client, adding entropy from the client side and providing mutual authentication benefits.
- **qop (quality of protection)**: Specifies the protection level, such as "auth" for authentication or "auth-int" for authentication with integrity protection.

This digest calculation cryptographically makes it impossible for an attacker to use hashed credentials that would work elsewhere. It provides several security improvements over basic authentication:

1. **Password Protection**: The actual password is never transmitted over the network
2. **Replay Attack Mitigation**: The nonce prevents replay of captured requests
3. **Mutual Authentication**: Both client and server can verify each other's identity
4. **Integrity Protection**: The digest includes the HTTP method and URI, preventing request tampering attacks

However, it's still recommended to use HTTPS for complete security, as Digest Authentication doesn't encrypt the entire communication channel.

### Sample Reques-Response Flow

Let's walk through a complete example of the Digest Authentication flow with actual HTTP headers and body content.

1. Initial request (no authentication):

```http
GET /profile/me HTTP/1.1
Host: localhost:8080
User-Agent: curl/8.4.0
Accept: */*
```

2. Server challenge response:

```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Digest realm="Protected API", nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093", algorithm="MD5", qop="auth"
Content-Type: text/plain
Content-Length: 23
Date: Thu, 17 Jul 2025 17:32:41 GMT

Authentication required
```

The server responds with a challenge containing:

- realm="Protected API": The protection space
- nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093": Server-generated unique value
- algorithm="MD5": Hash algorithm to use
- qop="auth": Quality of protection

Client Digest Calculation:

```
HA1 = MD5("john:Protected API:password123") 
    = MD5("john:Protected API:password123")
    = "939e7578ed9e3c518a452acee763bce9"

HA2 = MD5("GET:/profile/me")
    = "39aff3a2bab6126f332b942af96d3366"

cnonce = "0a4f113b"  // Client-generated nonce
nc = "00000001"      // Request count in hex

response = MD5("939e7578ed9e3c518a452acee763bce9:dcd98b7102dd2f0e8b11d0f600bfb0c093:00000001:0a4f113b:auth:39aff3a2bab6126f332b942af96d3366")
         = "6629fae49393a05397450978507c4ef1"
```

Authenticated Request:

```http
GET /profile/me HTTP/1.1
Host: localhost:8080
Authorization: Digest username="john", realm="Protected API", nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093", uri="/profile/me", algorithm="MD5", qop="auth", nc="00000001", cnonce="0a4f113b", response="6629fae49393a05397450978507c4ef1"
User-Agent: curl/8.4.0
Accept: */*
```

The Authorization header contains:

- `username="john"`: The username
- `realm="Protected API"`: Same as in challenge
- `nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093"`: Same as in challenge
- `uri="/profile/me"`: The requested URI
- `algorithm="MD5"`: Hash algorithm used
- `qop="auth"`: Quality of protection
- `nc="00000001"`: Nonce count (hexadecimal)
- `cnonce="0a4f113b"`: Client nonce
- `response="6629fae49393a05397450978507c4ef1"`: The computed digest

Failed Authentication Example

If the wrong password is provided, the digest calculation will be incorrect and server response for failed authentication:

```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Digest realm="Protected API", nonce="new_nonce_value_here", algorithm="MD5", qop="auth"
Content-Type: text/plain
Content-Length: 33
Date: Thu, 17 Jul 2025 17:35:15 GMT

Invalid username or password
```

Note that the server generates a new nonce for each failed authentication attempt, preventing replay attacks.

## Implementing Digest Authentication

### 1. Creating the Digest Calculation Utilities

First, let's create utilities for generating nonces and computing digests:

```scala
package example.auth.digest

import zio.http.Method
import java.net.URI
import java.nio.charset.StandardCharsets
import java.security.MessageDigest
import java.util.concurrent.ThreadLocalRandom

object DigestAuthentication {

  def generateNonce(): String = {
    val bytes = new Array[Byte](16)
    ThreadLocalRandom.current().nextBytes(bytes)
    bytes.map("%02x".format(_)).mkString
  }

  def md5Hash(input: String): String = MessageDigest
    .getInstance("MD5")
    .digest(input.getBytes(StandardCharsets.UTF_8))
    .map("%02x".format(_))
    .mkString

  def sha256Hash(input: String): String = {
    MessageDigest
      .getInstance("SHA-256")
      .digest(input.getBytes(StandardCharsets.UTF_8))
      .map("%02x".format(_))
      .mkString
  }

  private def computeHash(input: String, algorithm: String): String =
    algorithm.toLowerCase match {
      case "md5" | "md5-sess"         => md5Hash(input)
      case "sha-256" | "sha-256-sess" => sha256Hash(input)
      case _                          => md5Hash(input) // Default to MD5
    }

  def digestResponse(
    username: String,
    realm: String,
    uri: URI,
    algorithm: String = "MD5",
    qop: String = "auth",
    cnonce: String,
    nonce: String,
    nc: Int,
    userhash: Boolean = false,
    password: String,
    method: Method = Method.GET,
  ): String = {
    // Compute HA1 (hash of username:realm:password)
    val a1 = if (userhash) {
      // If userhash is true, username field should contain H(username:realm)
      s"$username:$password"
    } else {
      // Normal case: A1 = username:realm:password
      s"$username:$realm:$password"
    }

    val ha1 = algorithm.toLowerCase match {
      case alg if alg.endsWith("-sess") =>
        // For session algorithms, HA1 = H(H(username:realm:password):nonce:cnonce)
        val baseHash = computeHash(a1, algorithm)
        computeHash(s"$baseHash:$nonce:$cnonce", algorithm)
      case _                            =>
        computeHash(a1, algorithm)
    }

    // Compute HA2 (hash of method:uri)
    val a2  = s"$method:${uri.toString}"
    val ha2 = computeHash(a2, algorithm)

    // Compute response based on qop
    val response = qop.toLowerCase match {
      case "auth" | "auth-int" =>
        // Format: H(HA1:nonce:nc:cnonce:qop:HA2)
        val ncHex          = "%08x".format(nc)
        val responseString = s"$ha1:$nonce:$ncHex:$cnonce:$qop:$ha2"
        computeHash(responseString, algorithm)
      case _                   =>
        // Legacy format: H(HA1:nonce:HA2)
        val responseString = s"$ha1:$nonce:$ha2"
        computeHash(responseString, algorithm)
    }
    response
  }

  def validateDigest(
    response: String,
    username: String,
    realm: String,
    uri: URI,
    algorithm: String,
    qop: String,
    cnonce: String,
    nonce: String,
    nc: Int,
    userhash: Boolean,
    password: String,
    method: Method = Method.GET,
  ): Boolean = {
    val expectedResponse =
      digestResponse(
        username = username,
        realm = realm,
        uri = uri,
        algorithm = algorithm,
        qop = qop,
        cnonce = cnonce,
        nonce = nonce,
        nc = nc,
        userhash = userhash,
        password = password,
        method = method,
      )

    expectedResponse.equals(response)
  }
}
```

### 2. Creating the Authentication Middleware

Now let's implement the server-side middleware that handles Digest Authentication:

```scala
import DigestAuthentication.{generateNonce, validateDigest}
import zio._
import zio.http._

object DigestAuthenticationServer extends ZIOAppDefault {

  // Simple in-memory user store (username -> password)
  val users = Map(
    "john"  -> "password123",
    "jane"  -> "secret456", 
    "admin" -> "admin123",
  )

  val realm     = "Protected API"
  val algorithm = "MD5"

  // Digest authentication middleware
  val digestAuthMiddleware: HandlerAspect[Any, String] =
    HandlerAspect.interceptIncomingHandler(Handler.fromFunctionZIO[Request] { request =>
      request.header(Header.Authorization) match {
        case Some(header: Header.Authorization.Digest) =>
          // Check if user exists and validate digest
          users.get(header.username) match {
            case Some(password)
                if validateDigest(
                  header.response,
                  header.username,
                  header.realm,
                  header.uri,
                  header.algorithm,
                  header.qop,
                  header.cnonce,
                  header.nonce,
                  header.nc,
                  header.userhash,
                  password,
                  request.method,
                ) =>
              ZIO.succeed((request, header.username))
            case _ =>
              ZIO.fail(
                Response.unauthorized.addHeader(
                  Header.WWWAuthenticate.Digest(
                    realm = Some(realm),
                    nonce = Some(generateNonce()),
                    algorithm = Some(algorithm),
                    qop = Some("auth"),
                  ),
                ),
              )
          }

        case _ =>
          val nonce = generateNonce()
          ZIO.fail(
            Response.unauthorized.addHeader(
              Header.WWWAuthenticate.Digest(
                realm = Some(realm),
                nonce = Some(nonce),
                algorithm = Some(algorithm),
                qop = Some("auth"),
              ),
            ),
          )
      }
    })
}
```

This middleware examines incoming requests for Digest Authentication headers. If no authentication is provided, it sends a challenge with a new nonce. If authentication is provided, it validates the digest against the stored password.

### 3. Creating Protected Routes

Let's define routes that use our Digest Authentication middleware:

```scala
def routes: Routes[Any, Response] =
  Routes(
    // Serve the HTML client for testing
    Method.GET / Root -> handler { (_: Request) =>
      for {
        html <- loadHtmlFromResources("/digest-auth-client.html").orDie
      } yield Response(
        status = Status.Ok,
        headers = Headers(Header.ContentType(MediaType.text.html)),
        body = Body.fromString(html),
      )
    },

    // Protected profile route
    Method.GET / "profile" / "me" -> handler { (_: Request) =>
      ZIO.serviceWith[String] { username =>
        Response.text(s"Hello $username! This is your profile.")
      }
    } @@ digestAuthMiddleware,

    // Protected admin route - only for admin user
    Method.GET / "admin" -> handler { (_: Request) =>
      ZIO.serviceWith[String] { username =>
        if (username == "admin")
          Response.text(s"Welcome to admin panel, $username!")
        else
          Response.unauthorized(s"Access denied. User $username is not an admin.")
      }
    } @@ digestAuthMiddleware,

    // Public route (no authentication required)
    Method.GET / "public" -> handler { (_: Request) =>
      ZIO.succeed(Response.text("This is a public endpoint - no authentication required!"))
    },
  )
```

### 4. Complete Server Implementation

Here's the complete server code:

```scala
package example.auth.digest

import DigestAuthentication.{generateNonce, validateDigest}
import zio._
import zio.http._

import java.nio.charset.StandardCharsets
import scala.io.Source

object DigestAuthenticationServer extends ZIOAppDefault {

  val users = Map(
    "john"  -> "password123",
    "jane"  -> "secret456",
    "admin" -> "admin123",
  )

  val realm     = "Protected API"
  val algorithm = "MD5"

  val digestAuthMiddleware: HandlerAspect[Any, String] =
    HandlerAspect.interceptIncomingHandler(Handler.fromFunctionZIO[Request] { request =>
      request.header(Header.Authorization) match {
        case Some(header: Header.Authorization.Digest) =>
          users.get(header.username) match {
            case Some(password)
                if validateDigest(
                  header.response,
                  header.username,
                  header.realm,
                  header.uri,
                  header.algorithm,
                  header.qop,
                  header.cnonce,
                  header.nonce,
                  header.nc,
                  header.userhash,
                  password,
                  request.method,
                ) =>
              ZIO.succeed((request, header.username))
            case _ =>
              ZIO.fail(
                Response.unauthorized.addHeader(
                  Header.WWWAuthenticate.Digest(
                    realm = Some(realm),
                    nonce = Some(generateNonce()),
                    algorithm = Some(algorithm),
                    qop = Some("auth"),
                  ),
                ),
              )
          }

        case _ =>
          val nonce = generateNonce()
          ZIO.fail(
            Response.unauthorized.addHeader(
              Header.WWWAuthenticate.Digest(
                realm = Some(realm),
                nonce = Some(nonce),
                algorithm = Some(algorithm),
                qop = Some("auth"),
              ),
            ),
          )
      }
    })

  def routes: Routes[Any, Response] =
    Routes(
      Method.GET / Root -> handler { (_: Request) =>
        for {
          html <- loadHtmlFromResources("/digest-auth-client.html").orDie
        } yield Response(
          status = Status.Ok,
          headers = Headers(Header.ContentType(MediaType.text.html)),
          body = Body.fromString(html),
        )
      },

      Method.GET / "profile" / "me" -> handler { (_: Request) =>
        ZIO.serviceWith[String] { username =>
          Response.text(s"Hello $username! This is your profile.")
        }
      } @@ digestAuthMiddleware,

      Method.GET / "admin" -> handler { (_: Request) =>
        ZIO.serviceWith[String] { username =>
          if (username == "admin")
            Response.text(s"Welcome to admin panel, $username!")
          else
            Response.unauthorized(s"Access denied. User $username is not an admin.")
        }
      } @@ digestAuthMiddleware,

      Method.GET / "public" -> handler { (_: Request) =>
        ZIO.succeed(Response.text("This is a public endpoint - no authentication required!"))
      },
    )

  override val run =
    Server.serve(routes).provide(Server.default)

  def loadHtmlFromResources(resourcePath: String): ZIO[Any, Throwable, String] = {
    ZIO.attempt {
      val inputStream = getClass.getResourceAsStream(resourcePath)
      if (inputStream == null) throw new RuntimeException(s"Resource not found: $resourcePath")

      val source = Source.fromInputStream(inputStream, StandardCharsets.UTF_8.name())
      try source.mkString
      finally {
        source.close()
        inputStream.close()
      }
    }
  }
}
```

## Testing Digest Authentication

### Using curl

You can test the Digest Authentication using curl. First, make a request without authentication to get the challenge:

```bash
$ curl -v -X GET http://localhost:8080/profile/me
> GET /profile/me HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/8.4.0
> Accept: */*
>
< HTTP/1.1 401 Unauthorized
< www-authenticate: Digest realm="Protected API", nonce="a1b2c3d4e5f6", algorithm="MD5", qop="auth"
< date: Thu, 17 Jul 2025 17:32:41 GMT
< content-length: 0
```

Then use curl's built-in digest authentication support:

```bash
$ curl -v --digest -u john:password123 -X GET http://localhost:8080/profile/me
> GET /profile/me HTTP/1.1
> Host: localhost:8080
> Authorization: Digest username="john", realm="Protected API", nonce="a1b2c3d4e5f6", uri="/profile/me", cnonce="xyz123", nc=00000001, qop=auth, response="computed_digest", algorithm="MD5"
> User-Agent: curl/8.4.0
> Accept: */*
>
< HTTP/1.1 200 OK
< content-type: text/plain
< date: Thu, 17 Jul 2025 17:34:27 GMT
< content-length: 42
<
Hello john! This is your profile.
```

### ZIO HTTP Client Implementation

Here's how to implement a ZIO HTTP client that handles Digest Authentication:

```scala
package example.auth.digest

import DigestAuthentication._
import zio._
import zio.http._

import java.net.URI

object DigestAuthenticationClient extends ZIOAppDefault {

  val url      = "http://localhost:8080"
  val USERNAME = "john"
  val PASSWORD = "password123"

  val program: ZIO[Client, Throwable, Unit] =
    for {
      _             <- Console.printLine("=== Digest Authentication Demo ===\n")
      profileUrl    <- ZIO.fromEither(URL.decode(s"$url/profile/me"))
      
      // First request (expected to fail with 401)
      firstResponse <- ZClient.batched(Request(method = Method.GET, url = profileUrl))
      _             <- Console.printLine(s"First request status: ${firstResponse.status}")

      // If we get 401, extract challenge and retry with authentication
      result <-
        if (firstResponse.status == Status.Unauthorized) {
          firstResponse.header(Header.WWWAuthenticate) match {
            case Some(header: Header.WWWAuthenticate.Digest) =>
              val uri       = URI.create(profileUrl.path.toString)
              val cnonce    = generateNonce() // Generate random client nonce
              val nc        = 1
              val realm     = header.realm.getOrElse("")
              val nonce     = header.nonce.getOrElse("")
              val algorithm = header.algorithm.getOrElse("MD5")
              val qop       = header.qop.getOrElse("auth")

              // Compute response using enhanced digestResponse
              for {
                response <- ZClient.batched(
                  Request(method = Method.GET, url = profileUrl).addHeader(
                    Header.Authorization.Digest(
                      response = digestResponse(
                        username = USERNAME,
                        realm = realm,
                        uri = uri,
                        algorithm = algorithm,
                        qop = qop,
                        cnonce = cnonce,
                        nonce = nonce,
                        nc = nc,
                        password = PASSWORD,
                        method = Method.GET,
                      ),
                      username = USERNAME,
                      realm = realm,
                      nonce = nonce,
                      uri = uri,
                      algorithm = algorithm,
                      qop = qop,
                      nc = nc,
                      cnonce = cnonce,
                      userhash = false,
                      opaque = header.opaque.getOrElse(""),
                    ),
                  ),
                )
                body     <- response.body.asString
              } yield body

            case _ =>
              ZIO.fail(new RuntimeException("No valid WWW-Authenticate header found"))
          }
        } else
          firstResponse.body.asString

      _ <- Console.printLine(s"Response: $result")
      _ <- Console.printLine("\n=== Demo completed ===")
    } yield ()

  override val run = program.provide(Client.default)
}
```

## Advanced Features and Security Considerations

### 1. Nonce Management

In production systems, you should implement proper nonce management:

```scala
trait NonceService {
  def generateNonce(): UIO[String]
  def validateNonce(nonce: String): UIO[Boolean]
  def invalidateNonce(nonce: String): UIO[Unit]
}

case class InMemoryNonceService(
  private val nonces: Ref[Set[String]],
  private val maxAge: Duration = 5.minutes
) extends NonceService {

  def generateNonce(): UIO[String] = {
    val nonce = DigestAuthentication.generateNonce()
    nonces.update(_ + nonce) *> 
    ZIO.succeed(nonce)
  }

  def validateNonce(nonce: String): UIO[Boolean] =
    nonces.get.map(_.contains(nonce))

  def invalidateNonce(nonce: String): UIO[Unit] =
    nonces.update(_ - nonce)
}
```

### 2. Enhanced Security with SHA-256

While MD5 is widely supported, SHA-256 provides better security:

```scala
val digestAuthMiddlewareSecure: HandlerAspect[Any, String] =
  HandlerAspect.interceptIncomingHandler(Handler.fromFunctionZIO[Request] { request =>
    // ... authentication logic using SHA-256 algorithm
    val secureAlgorithm = "SHA-256"
    // ... rest of implementation
  })
```

### 3. Password Hashing Best Practices

Never store plain text passwords. Use proper password hashing:

```scala
import zio.Config.Secret

case class User(
  username: String, 
  hashedPassword: String, 
  salt: String,
  email: String,
  role: String
)

trait UserService {
  def authenticateWithHash(username: String, password: Secret): UIO[Option[User]]
}
```

### 4. Rate Limiting and Attack Prevention

Implement rate limiting to prevent brute force attacks:

```scala
def digestAuthWithRateLimit: HandlerAspect[Any, String] = 
  digestAuthMiddleware @@ 
  rateLimitMiddleware(maxAttempts = 5, window = 1.minute)
```

## Web Client Implementation

The provided HTML client demonstrates how to implement Digest Authentication in JavaScript:

Key features of the web client:
- Uses CryptoJS library for MD5 hashing
- Implements the full challenge-response flow
- Provides an intuitive interface for testing different endpoints
- Shows detailed logging of the authentication process

The client automatically:
1. Makes an initial request to trigger the challenge
2. Parses the `WWW-Authenticate` header
3. Computes the proper digest response
4. Retries the request with authentication

## Security Best Practices

When implementing Digest Authentication in production:

### 1. Use Strong Algorithms
- Prefer SHA-256 over MD5 when possible
- Consider SHA-256-sess for session-based scenarios

### 2. Implement Proper Nonce Management
- Generate cryptographically secure nonces
- Implement nonce expiration and validation
- Prevent nonce reuse attacks

### 3. Use HTTPS
- While Digest Authentication is more secure than Basic Authentication, HTTPS provides additional protection
- Protects against man-in-the-middle attacks
- Encrypts all communication, not just authentication

### 4. Password Storage Security
- Never store passwords in plain text
- Use proper password hashing (bcrypt, scrypt, or Argon2)
- Implement salt for additional security

### 5. Rate Limiting
- Implement rate limiting per IP address
- Use exponential backoff for failed attempts
- Monitor for unusual authentication patterns

### 6. Logging and Monitoring
- Log all authentication attempts
- Monitor for suspicious patterns
- Implement alerting for repeated failures

## Comparison with Other Authentication Methods

| Feature | Basic Auth | Digest Auth | JWT | OAuth 2.0 |
|---------|------------|-------------|-----|-----------|
| Password Transmission | Base64 (easily decoded) | Never transmitted | N/A | N/A |
| Replay Attack Protection | No | Yes (with nonce) | Yes (with expiration) | Yes |
| Stateless | Yes | Yes | Yes | No |
| Complexity | Low | Medium | Medium | High |
| Browser Support | Excellent | Good | Manual | Manual |
| Mobile App Support | Good | Good | Excellent | Excellent |

## Troubleshooting Common Issues

### 1. Digest Mismatch
If authentication fails with correct credentials:
- Verify the digest calculation order
- Check that the URI matches exactly (including query parameters)
- Ensure proper encoding of special characters

### 2. Nonce Validation Failures
- Check nonce expiration policies
- Verify nonce storage and retrieval mechanisms
- Ensure proper handling of nonce count (nc)

### 3. Algorithm Mismatches
- Verify both client and server use the same algorithm
- Check for case sensitivity in algorithm names
- Ensure proper fallback to supported algorithms

## Conclusion

Digest Authentication provides a significant security improvement over Basic Authentication by never transmitting passwords in plain text and offering protection against replay attacks. With ZIO HTTP, implementing Digest Authentication is straightforward and type-safe, allowing you to create secure APIs with minimal complexity.

The challenge-response mechanism, combined with cryptographic hashing, makes Digest Authentication suitable for many applications where Basic Authentication would be insufficient. However, for modern applications requiring advanced features like token refresh, fine-grained permissions, or third-party integration, consider more sophisticated authentication mechanisms like JWT or OAuth 2.0.

When implementing Digest Authentication, always follow security best practices, use HTTPS in production, implement proper password hashing, and consider rate limiting to protect against brute force attacks. The modular design of ZIO HTTP makes it easy to combine authentication with other security measures, creating robust and secure web applications.