---
id: digest-authentication
title: "Securing Your APIs: Digest Authentication"
---
# Digest Authentication

Digest Authentication is a more secure HTTP authentication method than Basic Authentication, designed to address the security vulnerabilities of transmitting credentials in easily decodable formats. In this guide, we'll explore how to implement Digest Authentication using ZIO HTTP, providing both server-side middleware and client-side integration.

## Understanding Digest Authentication

Digest Authentication, defined in RFC 2617 and extended in RFC 7616, is an HTTP authentication scheme that uses a **challenge-response mechanism with cryptographic hashing**. Unlike Basic Authentication, which transmits credentials in Base64 encoding, Digest Authentication never sends the actual raw password over the network. Instead, it uses hash functions to create a digest (typically MD5 or SHA-256) that proves the client knows the password without revealing it.

### The Challenge-Response Flow

The authentication process follows this sequence:

1. **Initial Request**: Client makes a request to a protected resource
2. **Challenge**: Server responds with `401 Unauthorized` and a `WWW-Authenticate` header containing:
    - `realm`: A string indicating the protection space
    - `nonce`: A server-generated unique value (prevents replay attacks)
    - `qop`: Quality of Protection (usually "auth")
    - `algorithm`: Hash algorithm to use (MD5, SHA-256, etc.)
3. **Response**: Client computes a digest using the provided parameters and its credentials, then retries the request with an `Authorization` header
4. **Verification**: Server validates the digest and grants or denies access

Here is an example of the initial request, the challenge response from the server, and the subsequent authenticated request:

1. First, client tries to access a protected resource on /profile/me without authentication: 

```http
GET /profile/me HTTP/1.1
Host: localhost:8080
```

2. The server responds with "401 Unauthorized" and a challenge:

```http
HTTP/1.1 401 Unauthorized
content-length: 0
date: Thu, 24 Jul 2025 07:27:40 GMT
www-authenticate: Digest realm="User Profile", nonce="MTc1MzM0MjA2MDI0NDpmbXNGK2dTblF4WEVwN1gwWktMVllRPT0=", opaque="uSla+F7cMBsB/t3K9OCLzg==", stale=false, algorithm=MD5, qop="auth", charset=UTF-8, userhash=false
```

This challenge says to the client that you are trying to access a protected resource in the "User Profile" realm, and you need to provide a valid digest which is generated using the provided parameters (`realm`, `nonce`, `algorithm`, etc.) and your credentials (username and password).

Please note that the challenge is sent by server in the `WWW-Authenticate` header, which is part of the HTTP response. 
- The `nonce` is a unique value generated by the server, and it changes for each authentication challenge to prevent replay attacks.
- The `realm` is a string that identifies the protected area, and it is used to group resources that require the same authentication behavior.
- The `algorithm` specifies the hashing algorithm the client should use to compute the digest. 
- The `qop` (Quality of Protection) specifies the protection level, such as "auth" for authentication or "auth-int" for authentication with integrity protection.

3. The client computes the digest, using the provided parameters and user's credentials. To compute the digest, the client uses the following formula:

```http
HA1 = H(username:realm:password)
HA2 = H(method:uri)
response = H(HA1:nonce:nc:cnonce:qop:HA2)
```

Let's explain each parameter in the formula:

- `username`: The username of the user trying to authenticate
- `realm`: The protection space, a string that identifies the protected area. This is provided by the server in the challenge in previous step.
- `password`: The password of the user trying to authenticate
- `method` and `uri`: The HTTP method and requested URI. These are used to ensure the digest is specific to the request being made, making request tampering attacks more difficult, as the digest is tied to the specific method and URI.
- `nonce`: A server-generated unique value that changes for each authentication challenge. It prevents replay attacks by ensuring each authentication exchange is unique.
- `nc` (nonce count): A hexadecimal counter that increments with each request using the same nonce. This allows the server to detect if requests are being replayed or received out of order. It is useful for defending against replay attacks. Assume attacker intercepts a very important request and tries to replay it later, the server can detect that the nonce count has already been used and reject the request.
- `cnonce` (client nonce): A random value generated by the client, adding entropy from the client side and providing mutual authentication benefits.
- `qop` (quality of protection): Specifies the protection level, such as "auth" for authentication or "auth-int" for authentication with integrity protection.

This digest calculation cryptographically makes it impossible for an attacker to use hashed credentials that would work elsewhere. It provides several security improvements over basic authentication:

1. **Password Protection**: The actual password is never transmitted over the network
2. **Replay Attack Mitigation**: The nonce prevents replay of captured requests. If two requests are made with the same nonce, the server can detect the replay attempt.
3. **Mutual Authentication**: Both client and server can verify each other's identity
4. **Integrity Protection**: The digest includes the HTTP method and URI, preventing request tampering attacks. Also, if the `qop` is set to `auth-int`, it includes the request body hash, ensuring the integrity of the request content.

However, with these security improvements, it's still necessary to use HTTPS for complete security, as Digest Authentication doesn't encrypt the entire communication channel.

Let's calculate the digest response using the formula above:

```
HA1 = H(username:realm:password)
= MD5(john:User Profile:password123)
= e858d07c1afb2c75ea1f1ee29c1d7702

HA2 = H(method:uri)
= MD5(GET:/profile/me)
= 509ae9f341ffefdd68447afcdae1e7bf

nonce  =  MTc1MzM0MjA2MDI0NDpmbXNGK2dTblF4WEVwN1gwWktMVllRPT0= // server-generated nonce
nc     = 00000001 // server-generated nonce count (hexadecimal)
qop    = auth
cnonce = 71n315lg67i4kr9473e5hw // client-generated nonce

response = H(HA1:nonce:nc:cnonce:qop:HA2)
= MD5(e858d07c1afb2c75ea1f1ee29c1d7702:MTc1MzM0MjA2MDI0NDpmbXNGK2dTblF4WEVwN1gwWktMVllRPT0:00000001:71n315lg67i4kr9473e5hw:auth:509ae9f341ffefdd68447afcdae1e7bf)
= f7e07fe43aa7a7e3a296edf8f3b3772a
```

After calculating the digest response, the client constructs the `Authorization` header with the computed values:

```http
GET /profile/me HTTP/1.1
Host: localhost:8080
Authorization: Digest username="john", realm="User Profile", nonce="MTc1MzM0MjA2MDI0NDpmbXNGK2dTblF4WEVwN1gwWktMVllRPT0=", uri="/profile/me", algorithm="MD5", qop="auth", nc="00000001", cnonce="71n315lg67i4kr9473e5hw", response="f7e07fe43aa7a7e3a296edf8f3b3772a", userhash=false, opaque="uSla+F7cMBsB/t3K9OCLzg=="
```

4. The server verifies the digest by recalculating it using the same parameters and its stored credentials for the user "john". If the digest matches, the server grants access to the requested resource. To do this, the server extracts the "username" parameter from the authorization header, then looks up the user's password in its database, now it can compute the digest using the same algorithm and parameters as the client. If the digest matches the one sent by the client, the server responds with the requested resource:

```http
HTTP/1.1 200 Ok
content-length: 76
content-type: text/plain
date: Wed, 23 Jul 2025 12:59:32 GMT

Hello john! This is your profile: 
 Username: john 
 Email: john@example.com
```

If the digest does not match, the server responds with `401 Unauthorized` again, indicating that the authentication failed with a new `WWW-Authenticate` header containing a new challenge.


## Implementing Digest Authentication

To implement Digest Authentication in ZIO HTTP, we are going to create a middleware that intercepts incoming requests, checks for the presence of the `Authorization` header, and validates the digest against stored user credentials. We'll also create a simple HTML client to demonstrate how to use Digest Authentication in practice.

ZIO HTTP currently does not have built-in support for Digest Authentication, but it has an excellent foundation for implementing it as a custom middleware.

### Overview

The middleware we are going to implement should handle the two main scenarios:

1. Check if the request contains an `Authorization` header. 
   - If it is present and of type `Header.Authorization.Digest`, it means the client is trying to authenticate by responding to a challenge from the server. So we need to validate the digest against the stored user credentials.
     - If the digest is valid, we allow the request to proceed.
     - If the digest is invalid, we respond with a `401 Unauthorized` status and a new challenge in the `WWW-Authenticate` header.
   - Otherwise, if the header is not present, this means the client is trying to access a protected resource without authentication, so we need to respond with a `401 Unauthorized` status and a `WWW-Authenticate` header containing the challenge parameters (realm, nonce, algorithm, etc.).

```scala
val digestAuthHandler: HandlerAspect[Any, Unit] =
   HandlerAspect.interceptIncomingHandler[Any, Unit] {
      Handler.fromFunctionZIO[Request](request =>
         request.header(Header.Authorization) match {
            // If the request contains a Digest Authorization header
            case Some(authHeader: Header.Authorization.Digest) =>
               // 1. find the user's credentials in the database using the username from header
               // 2. validate the digest against stored user credentials
               // 3. if valid, allow the request to proceed
               // 4. if invalid, respond with 401 Unauthorized with a new challenge
   
            // No auth header or not digest, send challenge
            case _ =>
             // 1. respond with 401 Unauthorized with a new challenge
         },
      )
   }
```

### Digest Authentication Service Interface

There are two main operations we need to implement:

   - **Creating a challenge**: When the client tries to access a protected resource without authentication, we need to generate a challenge that includes the realm, nonce, algorithm, and quality of protection (qop). The server generates the challenge and sends it back to the client in the `WWW-Authenticate` header of the response.
   - **Validating the response**: When the client responds with a digest in the `Authorization` header, the server needs to validate it against the stored user credentials. This involves computing the expected digest and comparing it with the one sent by the client.

It is good to put these functionalities into a separate service called `DigestAuthService`:

```scala
trait DigestAuthService {
   def generateChallenge(
     realm: String,
     qop: List[QualityOfProtection],
     algorithm: HashAlgorithm
   ): UIO[DigestChallenge]

   def validateResponse(
     digest: DigestResponse,
     password: Secret,
     method: Method,
     body: Option[String] = None,
   ): ZIO[Any, DigestAuthError, Boolean]
}
```

The `DigestAuthService#createChallenge` method generates a new challenge to send to the client when they attempt to access a protected resource without authentication. The `DigestAuthService#validateResponse` method checks if the provided digest response by the client is valid.

The `DigestChallenge` is a data type that encapsulates the parameters needed to generate a challenge, such as `realm`, `nonce`, `opaque`, `algorithm`, and `qop`:

```scala
case class DigestChallenge(
  realm: String,
  nonce: String,
  opaque: Option[String] = None,
  algorithm: DigestAlgorithm = MD5,
  qop: List[QualityOfProtection] = List(Auth),
  stale: Boolean = false,
  domain: Option[List[String]] = None,
  charset: Option[String] = Some("UTF-8"),
  userhash: Boolean = false,
) {
  def toHeader: Header.WWWAuthenticate.Digest = ???
}
```

The `DigestChallenge#toHeader` method converts the `DigestChallenge` into a `Header.WWWAuthenticate.Digest`, which can be used in the HTTP response to challenge the client.

The `DigestResponse` is a data type that represents the response sent by the client in the `Authorization` header, containing the username, realm, nonce, cnonce, nc, qop, uri, and response digest.

```scala
case class DigestResponse(
  response: String,
  username: String,
  realm: String,
  uri: URI,
  opaque: String,
  algorithm: DigestAlgorithm,
  qop: QualityOfProtection,
  cnonce: String,
  nonce: String,
  nc: String,
  userhash: Boolean,
)

object DigestResponse {
  def fromHeader(digest: Header.Authorization.Digest): DigestResponse = ???
}
```

The `DigestResponse.fromHeader` translate the `Header.Authorization.Digest` to `DigestResponse` which is a more typesafe representation of digest response.

The `DigestAuthError` is a sealed trait that represents the possible errors that can occur during the digest authentication process. It includes:

```scala
sealed trait NonceError extends Serializable with Product
object NonceError {
  case class NonceExpired(nonce: String)                 extends NonceError
  case class NonceAlreadyUsed(nonce: String, nc: String) extends NonceError
  case class InvalidNonce(nonce: String)                 extends NonceError
}
```

The `DigestAlgorithm` is an enum that represents the hashing algorithms used in Digest Authentication. It includes common algorithms like MD5, SHA-256, and SHA-512, along with their session variants:

```scala
sealed abstract class DigestAlgorithm(val name: String, val digestSize: Int) {
  override def toString: String = name
}

object DigestAlgorithm {
  case object MD5         extends DigestAlgorithm("MD5", 128)
  case object MD5_SESS    extends DigestAlgorithm("MD5-sess", 128)
  case object SHA256      extends DigestAlgorithm("SHA-256", 256)
  case object SHA256_SESS extends DigestAlgorithm("SHA-256-sess", 256)
  case object SHA512      extends DigestAlgorithm("SHA-512", 512)
  case object SHA512_SESS extends DigestAlgorithm("SHA-512-sess", 512)

  val values: List[DigestAlgorithm] =
    List(MD5, MD5_SESS, SHA256, SHA256_SESS, SHA512, SHA512_SESS)

  def fromString(s: String): Option[DigestAlgorithm] =
    values.find(_.name.equalsIgnoreCase(s.trim))
}
```

The `QualityOfProtection` is a sealed trait that represents the quality of protection used in Digest Authentication. It includes two common values: `auth` and `auth-int`. The `auth` value indicates that the request is authenticated, while `auth-int` indicates that the request is authenticated and the integrity of the request body is protected:

```scala
sealed abstract class QualityOfProtection(val name: String) {
  override def toString: String = name
}

object QualityOfProtection {
  case object Auth     extends QualityOfProtection("auth")
  case object AuthInt  extends QualityOfProtection("auth-int")

  val values: List[QualityOfProtection] = List(Auth, AuthInt)

  def fromString(s: String): Option[QualityOfProtection] =
    values.find(_.name.equalsIgnoreCase(s.trim))
}
```

Now that we have defined the service interface and the supporting types, we are ready to dive into the implementation details of the `DigestAuthService`.

### Nonce Management Service

The important aspect of the challenge generation is the `nonce` generation. The `nonce` is a unique value generated by the server for each challenge, which prevents replay attacks and ensures freshness in the authentication process. It should be a random value that changes for each request/session, so that reuse (replay) of old requests is not possible.

There is no mandated algorithm for nonce generation, but here are some common approaches:

- **Random Nonce**: The nonce can be a random value generated by the server. This is a simple approach but requires the server to keep track of used nonces to prevent replay attacks. After receiving back the response to a challenge, if the digest is valid, the server should mark the nonce as used, so it cannot be reused in subsequent requests. With this approach the server do not use the nonce count (`nc`), as the nonce itself is unique for api session and cannot be reused:

```scala
val nonce = 
  Random.nextBytes(16)
    .map(_.toArray)
    .map(Base64.getEncoder.encodeToString) 
// e.g. nonce: pY0+z+EeTgrXwq/Y3L8lGA==
```

- **Timestamp-based Nonce**: The nonce can be a combination of the current timestamp and a random value or hash of the timestamp. This allows the server to check if a nonce is too old and reject it, reducing the window of the session for replay attacks. After receiving back the response to a challenge, if the digest is valid, the server should first check if the nonce is still valid (not expired) and then mark the combination of `nonce` and `nc` as used, so it cannot be reused in subsequent requests. The next request with the same nonce should increment the `nc` value to indicate that it is a new request. Using this approach, we can use the same nonce for multiple requests until the window of the session expires.

To implement these functionalities, we are going to create a `NonceService` that will handle nonce generation, validation, tracking of used nonces:

```scala
trait NonceService {
  def generateNonce: UIO[String]
  def validateNonce(nonce: String, maxAge: Duration): UIO[Boolean]
  def isNonceUsed(nonce: String, nc: String): UIO[Boolean]
  def markNonceUsed(nonce: String, nc: String): UIO[Unit]
}
```

Let's start by implementing the `generateNonce` method:

```scala
final case class NonceServiceLive(
  secretKey: Secret
) extends NonceService {
  private val HASH_ALGORITHM = "HmacSHA256"
  private val HASH_LENGTH    = 16

  def generateNonce: UIO[String] = 
    Clock.currentTime(TimeUnit.MILLISECONDS).map { timestamp =>
      val hash    = Base64.getEncoder.encodeToString(createHash(timestamp))
      val content = s"$timestamp:$hash"
      Base64.getEncoder.encodeToString(content.getBytes("UTF-8"))
    }
  
  def validateNonce(nonce: String, maxAge: Duration): UIO[Boolean] = ???
  def isNonceUsed(nonce: String, nc: String): UIO[Boolean] = ???
  def markNonceUsed(nonce: String, nc: String): UIO[Unit] = ???

  private def createHash(timestamp: Long): Array[Byte] = {
    val mac = Mac.getInstance(HASH_ALGORITHM)
    mac.init(new SecretKeySpec(secret.stringValue.getBytes("UTF-8"), HASH_ALGORITHM))
    mac.doFinal(timestamp.toString.getBytes("UTF-8")).take(HASH_LENGTH)
  }
}
```

Each nonce generated by this method has two parts: 

```
nonce = Base64(timestamp:Base64(KD(timestamp)))
```

The `timestamp` is the current time in milliseconds, and `KD(timestamp)` is the HMAC hash of the timestamp using a secret key known only to the server. The nonce is then Base64-encoded to ensure it can be safely transmitted in HTTP headers.

When receiving nonce from the client, the server should decode it, extract the timestamp and hash, check if the nonce is valid:
- First check if the timestamp is within an acceptable range (e.g., not older than a certain duration, like 5 minutes). This prevents replay attacks by ensuring that the nonce is fresh.
- Then, verify that the hash matches the computed hash for the given timestamp using the same secret key. This allows the server to ensure that the nonce was generated by the server and has not been tampered with.

Let's implement the `validateNonce` method to check if the nonce is valid:

```scala
final case class NonceServiceLive(secretKey: Secret) extends NonceService {
  private def computeHash(timestamp: Long, secretKey: Secret): Array[Byte] = ???
    
  def generateNonce: UIO[String] = ???

  def validateNonce(nonce: String, maxAge: Duration): ZIO[Any, NonceError, Unit] =
    ZIO.fromEither {
      try {
        val decoded = new String(Base64.getDecoder.decode(nonce), "UTF-8")
        val parts   = decoded.split(":", 2)

        if (parts.length != 2) {
          Left(NonceError.InvalidNonce(nonce))
        } else {
          val timestamp         = parts(0).toLong
          val providedHash      = Base64.getDecoder.decode(parts(1))
          val isWithinTimeLimit = java.lang.System.currentTimeMillis() - timestamp <= maxAge.toMillis

          if (!isWithinTimeLimit) {
            Left(NonceError.NonceExpired(nonce))
          } else if (!constantTimeEquals(createHash(timestamp), providedHash)) {
            Left(NonceError.InvalidNonce(nonce))
          } else {
            Right(())
          }
        }
      } catch {
        case _: Exception => Left(NonceError.InvalidNonce(nonce))
      }
    }
  
  def isNonceUsed(nonce: String, nc: String): UIO[Boolean] = ???
  def markNonceUsed(nonce: String, nc: String): UIO[Unit] = ???
    
  private def constantTimeEquals(a: Array[Byte], b: Array[Byte]): Boolean =
    a.length == b.length && a.zip(b).map { case (x, y) => x ^ y }.fold(0)(_ | _) == 0
}
```

After validating the nonce, we should also check if the nonce has already been used in a previous request. This can be done by maintaining a map of used nonces and their associated counts (`nc`). If the nonce is found in the set, it means it has already been used, and we should reject the request. We implement `isNonceUsed` method to check if a nonce has been used:

```scala
final case class NonceServiceLive(
    usedNonce: Ref[Map[String, Set[String]]],
    secretKey: SecretKey
  ) extends NonceService {
  def generateNonce: UIO[String] = ???
  def validateNonce(nonce: String, maxAge: Duration): UIO[Boolean] = ???

  def isNonceUsed(nonce: String, nc: String): ZIO[Any, NonceError, Unit] =
    usedNonces.get.map(_.get(nonce).exists(_.contains(nc))).flatMap { isUsed =>
      ZIO.when(isUsed)(ZIO.fail(NonceError.NonceAlreadyUsed(nonce, nc))).unit
    }
    
  def markNonceUsed(nonce: String, nc: String): UIO[Unit] = ???
}
```

Similarly, we have to implement the `markNonceUsed` method to mark a nonce as used after a successful authentication:

```scala
final case class NonceServiceLive(
    usedNonce: Ref[Map[String, Set[String]]],
    secretKey: SecretKey
  ) extends NonceService {
  def generateNonce: UIO[String] = ???
  
  def validateNonce(nonce: String, maxAge: Duration): UIO[Boolean] = ???

  def isNonceUsed(nonce: String, nc: String): ZIO[Any, NonceError, Unit] =
    usedNonces.get.map(_.get(nonce).exists(_.contains(nc))).flatMap { isUsed =>
      ZIO.when(isUsed)(ZIO.fail(NonceError.NonceAlreadyUsed(nonce, nc))).unit
    }

  def markNonceUsed(nonce: String, nc: String): UIO[Unit] =
    usedNonces.update(nonces => nonces.updated(nonce, nonces.getOrElse(nonce, Set.empty) + nc))
}
```

The nonce generation and validation logic is now encapsulated in the `NonceService`, which can be injected into the `DigestAuthService` to handle nonce management during the digest authentication process. 

It is time to think about computing the digest response, which is the next step in implementing the `DigestAuthService`.

### Digest Response Service

Let's create another service that is responsible for calculating the digest response based on the provided parameters:

```scala
trait DigestService {
  def calculateResponse(
    username: String,
    realm: String,
    password: Secret,
    nonce: String,
    nc: String,
    cnonce: String,
    algorithm: DigestAlgorithm,
    qop: QualityOfProtection,
    uri: URI,
    method: Method,
    body: Option[String] = None,
  ): UIO[String]
}
```

As we discussed earlier, the digest response is calculated using the following formula:

```
HA1 = H(username:realm:password)
HA2 = H(method:uri)
response = H(HA1:nonce:nc:cnonce:qop:HA2)
```

But this is the simple version of the digest calculation, when the algorithm is a regular algorithm, e.g. `MD5`, `SHA-256`. If the algorithm is a session algorithm (ending with "-sess", e.g., `MD5-sess`, `SHA-256-sess`), the `HA1` is calculated differently:

```
If algorithm ends in "-sess":
    HA1 = H(H(username:realm:password):nonce:cnonce)
otherwise:
    HA1 = H(username:realm:password)
HA2 = H(method:uri)
response = H(HA1:nonce:nc:cnonce:qop:HA2)
```

In regular algorithms, the `HA1` is a constant value for a given `username`, `realm`, and `password`. This means that if an attacker captures the `HA1` value, they can use it to generate valid digests for any request made by that user.

The session algorithms are variants of a digest algorithm that enhance security by making the hash depend not only on the `username`, `realm`, and `password` but also on values that are unique to each session, such as the server nonce (`nonce`) and the client nonce (`cnonce`).

If someone steals `H(username:realm:password)` from the client, e.g., via sniffing or memory dump, they still can't generate a valid digest without knowing the specific `nonce` and `cnonce` values.

So, as security best practices, always prefer `-sess` algorithms, if both the client and server support them, especially over unsecured networks.

Now, let's implement the `computeResponse` method in the `DigestService`:

```scala
def computeResponse(
  username: String,
  realm: String,
  password: Secret,
  nonce: String,
  nc: String,
  cnonce: String,
  algorithm: DigestAlgorithm,
  qop: QualityOfProtection,
  uri: URI,
  method: Method,
  body: Option[String] = None,
): UIO[String] =
  for {
    a1       <- computeA1(username, realm, password, nonce, cnonce, algorithm)
    ha1      <- hash(a1, algorithm)
    a2       <- computeA2(method, uri, algorithm, qop, body)
    ha2      <- hash(a2, algorithm)
    response <- computeFinalResponse(ha1, ha2, nonce, nc, cnonce, qop, algorithm)
  } yield response
```

Calculation of a1 is easy, based on the type of the algorithm, we can either use the simple formula or the session formula:

```scala
private def computeA1(
  username: String,
  realm: String,
  password: Secret,
  nonce: String,
  cnonce: String,
  algorithm: DigestAlgorithm,
): UIO[String] = {
  val baseA1 = s"$username:$realm:${password.stringValue}"

  algorithm match {
    case DigestAlgorithm.MD5_SESS | DigestAlgorithm.SHA256_SESS | DigestAlgorithm.SHA512_SESS =>
      hash(baseA1, algorithm)
        .map(ha1 => s"$ha1:$nonce:$cnonce")
    case _                                                                                    =>
      ZIO.succeed(baseA1)
  }
}
```

Creating the `a2` is also straightforward, it is just a hash of the HTTP method and URI. In case of `auth-int` quality of protection, we also need to include the request body in the calculation:

```scala
private def computeA2(
  method: Method,
  uri: URI,
  algorithm: DigestAlgorithm,
  qop: QualityOfProtection,
  entityBody: Option[String],
): UIO[String] = {
  qop match {
    case QualityOfProtection.AuthInt =>
      entityBody match {
        case Some(body) =>
          hash(body, algorithm)
            .map(hbody => s"${method.name}:${uri.getPath}:$hbody")
        case None       =>
          ZIO.succeed(s"${method.name}:${uri.getPath}:")
      }
    case _                           =>
      ZIO.succeed(s"${method.name}:${uri.getPath}")
  }
}
```

And here is the final response generation:

```scala
private def computeFinalResponse(
  ha1: String,
  ha2: String,
  nonce: String,
  nc: String,
  cnonce: String,
  qop: QualityOfProtection,
  algorithm: DigestAlgorithm,
): UIO[String] = 
  hash(s"$ha1:$nonce:$nc:$cnonce:${qop.name}:$ha2", algorithm)
```

The `hash` function is a utility function that computes the hash of a given string using the specified algorithm. It can be implemented using Java's `MessageDigest` or any other hashing library:

```scala
private def hash(data: String, algorithm: DigestAlgorithm): UIO[String] =
  ZIO.succeed {
    val md = algorithm match {
      case MD5 | MD5_SESS       =>
        MessageDigest.getInstance("MD5")
      case SHA256 | SHA256_SESS =>
        MessageDigest.getInstance("SHA-256")
      case SHA512 | SHA512_SESS =>
        MessageDigest.getInstance("SHA-512")
    }
    md.digest(data.getBytes("UTF-8"))
      .map(b => String.format("%02x", b & 0xff))
      .mkString
  }
```

### Digest Authentication Service Implementation

#### Generating a Challenge

Let's implement the `generateChallenge` method in the `DigestAuthService`:

```scala
case class DigestAuthServiceLive(
  nonceService: NonceService,
) extends DigestAuthService {
  def generateChallenge(
    realm: String,
    qop: List[QualityOfProtection],
    algorithm: HashAlgorithm,
  ): UIO[DigestChallenge] =
    for {
      nonce     <- nonceService.generateNonce
      opaque    <- generateOpaque
    } yield DigestChallenge(
      realm = realm,
      nonce = nonce,
      opaque = Some(opaque),
      algorithm = algorithm,
      qop = qop,
    )

  private def generateOpaque: UIO[String] =
    Random
      .nextBytes(OPAQUE_BYTES_LENGTH)
      .map(_.toArray)
      .map(Base64.getEncoder.encodeToString)
}
```

The `opaque` is an optional value chosen by the server, and the client should copy back unchanged in the `Authorization` header when responding to the challenge.

[//]: # (Please note that `DigestChallenge` and `DigestResponse` are custom data types that encapsulate the digest challenge parameters and the digest response, respectively. They has the same structure as `Header.WWWAuthenticate.Digest` and `Header.Authorization.Digest`, but with more type safety guarantees.)


[//]: # (To validate the digest header, we also should pass the password and method of the request, and optionally the body if we want to validate the integrity of the request body as well. Integrity of the request body is only required if the `qop` is set to `auth-int`, which means that the request body has been included in the digest calculation.)

#### Validating the Challenge Response

Another method we need to implement is `validateResponse`, which checks if the provided digest response is valid or not. This method will compute the expected digest using the provided parameters and compare it with the one sent by the client.


Let's implement the `validateResponse` method in the `DigestAuthService`:

```scala
case class DigestAuthServiceLive(
  nonceService: NonceService,
  digestService: DigestService,
) extends DigestAuthService {

  def generateChallenge(
    realm: String,
    qop: List[QualityOfProtection],
    algorithm: HashAlgorithm,
  ): UIO[DigestChallenge] = ???

  def validateResponse(
    response: DigestResponse,
    password: Secret,
    method: Method,
    body: Option[String] = None,
  ): ZIO[Any, DigestAuthError, Unit] = {
    val r = response
    for {
      _        <- nonceService.validateNonce(r.nonce, Duration.fromSeconds(NONCE_MAX_AGE)).mapError(errorMapper)
      _        <- nonceService.isNonceUsed(r.nonce, r.nc).mapError(errorMapper)
      expected <- digestService.computeResponse(r.username, r.realm, password, r.nonce, r.nc, r.cnonce, r.algorithm, r.qop, r.uri, method, body)
      _        <- isEqual(expected, r.response)
      _        <- nonceService.markNonceUsed(r.nonce, r.nc)
    } yield ()
  }
}
```

The validation process involves several steps:
1. **Nonce Validation**: Check if the nonce is valid and not expired using the `NonceService`.
2. **Replay Attack Check**: Ensure that the nonce has not been used before with the same `nc` (nonce count) using the `NonceService`.
3. **Calculate the Expected Response**: Compute the expected response digest using the provided parameters and the user's password.
4. **Comparing Responses**: Compare the expected response with the one provided by the client.
5. **Marking Nonce as Used**: If the response is valid, mark the nonce as used to prevent replay attacks in future requests.

Among these steps, the remain part is the comparison of the expected response with the one provided by the client. This is done using a constant-time comparison to prevent timing attacks:

```scala
private def isEqual(expected: String, actual: String): ZIO[Any, InvalidResponse, Unit] = {
  val exp = expected.getBytes("UTF-8")
  val act = actual.getBytes("UTF-8")
  if (MessageDigest.isEqual(exp, act))
    ZIO.unit
  else
    ZIO.fail(InvalidResponse(expected, actual))
}
```

## User Service

Beside the `DigestAuthService`, we also need a `UserService` to store and retrieve user credentials. This service will provide methods to authenticate users and retrieve their passwords:

```scala
import zio._
import zio.Config._

case class User(username: String, password: Secret, email: String)

sealed trait UserServiceError
object UserServiceError {
  case class UserNotFound(username: String)      extends UserServiceError
  case class UserAlreadyExists(username: String) extends UserServiceError
}

trait UserService {
  def getUser(username: String): IO[UserServiceError, User]
  def addUser(user: User): IO[UserServiceError, Unit]
  def updateEmail(username: String, newEmail: String): IO[UserServiceError, Unit]
}
```

For the sake of simplicity, we can use an in-memory store for users, but in a real application, you would typically use a database or another persistent storage solution:

```
case class UserServiceLive(users: Ref[Map[String, User]]) extends UserService {

  def getUser(username: String): IO[UserServiceError, User] = {
    for {
      userMap <- users.get
      user    <- ZIO
        .fromOption(userMap.get(username))
        .orElseFail(UserServiceError.UserNotFound(username))
    } yield user
  }

  def addUser(user: User): IO[UserServiceError, Unit] = {
    for {
      userMap <- users.get
      _       <- ZIO.when(userMap.contains(user.username))(
        ZIO.fail(UserServiceError.UserAlreadyExists(user.username)),
      )
      _       <- users.update(_.updated(user.username, user))
    } yield ()
  }

  def updateEmail(username: String, newEmail: String): IO[UserServiceError, Unit] = for {
    updated <- users.modify { currentUsers =>
      currentUsers.get(username) match {
        case Some(user) =>
          val updatedUser = user.copy(email = newEmail)
          (Right(()), currentUsers.updated(username, updatedUser))
        case None       =>
          (Left(UserServiceError.UserNotFound(username)), currentUsers)
      }
    }
    _       <- ZIO.fromEither(updated)
  } yield ()
}

object UserService {
   private val initialUsers = Map(
      "john"  -> User("john", Secret("password123"), "john@example.com"),
      "jane"  -> User("jane", Secret("secret456"), "jane@example.com"),
      "admin" -> User("admin", Secret("admin123"), "admin@company.com"),
   )

   val live: ZLayer[Any, Nothing, UserService] =
      ZLayer.fromZIO(Ref.make(initialUsers).map(UserServiceLive(_)))
}
```

## Implementing the Middleware

The middleware uses the `UserService` to retrieve user credentials to be able to validate the digest. We can make our middleware more flexible by passing the user details to the outgoing request context in case of success of validation, so that downstream handlers can access the authenticated user information:

```scala
import zio._
import zio.http._

object DigestAuthHandlerAspect {

  def apply(
    realm: String,
    qop: List[QualityOfProtection] = List(Auth),
    supportedAlgorithms: Set[DigestAlgorithm] = Set(MD5, MD5_SESS, SHA256, SHA256_SESS, SHA512, SHA512_SESS),
  ): HandlerAspect[DigestAuthService & UserService, User] = {

    def unauthorizedResponse(message: String): ZIO[DigestAuthService, Response, Nothing] =
      ZIO
        .collectAll(
          supportedAlgorithms
            .map(algorithm => ZIO.serviceWithZIO[DigestAuthService](_.generateChallenge(realm, qop, algorithm))),
        )
        .flatMap(challenges =>
          ZIO.fail(
            Response
              .unauthorized(message)
              .addHeaders(Headers(challenges.map(_.toHeader))),
          ),
        )

    HandlerAspect.interceptIncomingHandler[DigestAuthService & UserService, User] {
      handler { (request: Request) =>
        request.header(Header.Authorization) match {
          case Some(digest: Header.Authorization.Digest) =>
            {
              for {
                user        <- ZIO.serviceWithZIO[UserService](_.getUser(digest.username))
                body        <- request.body.asString.option
                authService <- ZIO.service[DigestAuthService]
                _    <- authService.validateResponse(DigestResponse.fromDigestHeader(digest), user.password, request.method, body)
              } yield (request, user)
            }.catchAll(_ => unauthorizedResponse("Authentication failed!"))

          case _ =>
            unauthorizedResponse(s"Missing Authorization header for realm: $realm")
        }
      }

    }
  }

}
```

This middleware takes three parameters:

- `realm`: The realm for the digest authentication, which is a string that identifies the protected area we are going to protect.
- `qop`: A list of `QualityOfProtection` values that specifies the quality of protection to use, such as `auth` or `auth-int` or both of them. The challenge generated by the middleware will include these values in the `qop` parameter. For example, if the `qop` is set to `List(Auth, AuthInt)`, the challenge will include both `auth` and `auth-int` in the `qop` parameter, allowing the client to choose which one to use.
- `supportedAlgorithms`: A set of `HashAlgorithm` values that specifies the supported hashing algorithms for digest authentication. The middleware will generate challenges for each of the supported algorithms, allowing the client to choose which one to use. For example, if the `supportedAlgorithms` is set to `Set(MD5, SHA256)`, the challenge will include both `MD5` and `SHA-256` headers, allowing the client to pick one of them.

To decode and extract the digest parameters from incoming request, we do not require any extra effort, as ZIO HTTP extracts the `Authorization` header and is accessible via `request.header(Header.Authorization)` header. If the header is present, we can check if it is of type `Header.Authorization.Digest`, which contains all the necessary parameters for digest authentication.


## Applying the Middleware

Now we can finally use this middleware in our ZIO HTTP application to protect our `/profile/me` route:

```scala
val profileRoute: Route[DigestAuthService & UserService, Nothing] =
  Method.GET / "profile" / "me" -> handler { (_: Request) =>
    for {
      user <- ZIO.service[User]
    } yield Response.text(
      s"Hello ${user.username}! This is your profile: \n Username: ${user.username} \n Email: ${user.email}",
    )
  
  } @@ DigestAuthHandlerAspect(realm = "User Profile")
```

Applying this middleware to our route, requires two services in the environment: `DigestAuthService` and `UserService`. The `DigestAuthService` is responsible for generating challenges and validating responses, while the `UserService` provides user credentials for authentication.

The beautiful thing about this middleware is that it extracts the authenticated user from the request and makes it available to downstream handlers. This allows us to access the user information in the handler using the ZIO environment (`ZIO.service[User]`) without having to pass it explicitly.

Let's write another route for updating the user's email, which is also should be protected by the digest authentication middleware. The difference is that this route will require the user to provide a new email address in the request body to update their profile:

```
PUT /profile/me/email HTTP/1.1
Host: localhost:8080
Authorization: Digest ...
Content-Type: application/json
Content-Length: 42

{
  "email": "my-new-email@example.com"
}
```

As this route has a request body, we need to ensure that the `qop` is set to `auth-int`, which means that the request body will be included in the digest calculation. This way, the server can verify the integrity of the request body and ensure that it has not been tampered with:

```scala
val updateEmailRoute: Route[DigestAuthService & UserService, Nothing] =
  Method.PUT / "profile" / "email" ->
    Handler.fromZIO(ZIO.service[UserService]).flatMap { userService =>
      handler { (req: Request) =>
        for {
          user <- ZIO.service[User]
          updateRequest <- req.body
            .to[UpdateEmailRequest]
            .mapError(error => Response.badRequest(s"Invalid JSON (UpdateEmailRequest): $error"))
          _ <- userService
            .updateEmail(user.username, updateRequest.email)
            .logError(s"Failed to update email for user ${user.username}")
            .mapError(_ => Response.internalServerError(s"Failed to update email!"))
        } yield Response.text(
          s"Email updated successfully for user ${user.username}! New email: ${updateRequest.email}",
        )
      } @@ DigestAuthHandlerAspect(realm = "User Profile", qop = List(AuthInt))
    }
```

There are some notes to consider when writing this route:
- First, we used `List(AuthInt)` as the Quality of Protection (`qop`) parameter, this enforces the client to include the request body in the digest calculation, ensuring that the integrity of the request body is verified by the server. Please note that we can aslo include the `Auth` value in the `qop` list, which makes the client to optionally pick either `auth` or `auth-int` for the authentication request.
- Second, in the implementation of the route, we extracted the user details from the ZIO environment using the `ZIO.service[User]` method, which is made available by the `DigestAuthHandlerAspect`. Besides this, we also need obtaining the `UserService` from the ZIO environmet to update the user's email. If we do both of these inside one handler, the type of our handler becomes `Handler[User & UserService, Response, Request, Response]`, on the other hand, the type of the `DigestAuthHandlerAspect` is `HandlerAspect[DigestAuthService & UserService, User]`. The type of the handler aspect, tells us that it only apply to a handler that its environment is subset of `User`. So it can't be applied to a handler that requires both `User` and `UserService` in its environment. To solve this, we chained two handlers using `flatMap`, where the first handler extracts the `UserService` from the environment, and the second handler uses it to update the user's email. So the inner handler has the type `Handler[User, Response, Request, Response]`, which is compatible with the `DigestAuthHandlerAspect` that requires only `User` in its environment. So now we can apply the `DigestAuthHandlerAspect` to the inner handler and chain it with the outer handler that extracts the `UserService` from the environment.





