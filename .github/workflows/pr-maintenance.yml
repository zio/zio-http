name: PR Maintenance

on:
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review]
  schedule:
    - cron: '17 3 * * *'
  workflow_dispatch:
    inputs:
      thresholdDays:
        description: 'Days without a successful build before auto-closing'
        required: false
        default: '5'

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: read
  statuses: read

env:
  THRESHOLD_DAYS: ${{ inputs.thresholdDays || '5' }}

jobs:
  pr_closing_keyword_reminder:
    name: PR keyword reminder
    if: ${{ github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest
    steps:
      - name: Check PR keyword
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const pr = context.payload.pull_request;
            // Ignore drafts explicitly
            if (!pr || pr.draft) {
              return;
            }

            const body = (pr.body || '').toLowerCase();
            // Accept close/fix/resolve variants followed by: #123, owner/repo#123, or a full issues URL
            const keywordRe = /(close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s+(?:#[0-9]+|https?:\/\/github\.com\/[A-Za-z0-9_.-]+\/[A-Za-z0-9_.-]+\/issues\/[0-9]+|[A-Za-z0-9_.-]+\/[A-Za-z0-9_.-]+#[0-9]+)/i;

            if (keywordRe.test(body)) return;

            // Avoid duplicate reminders by checking existing bot comments
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              per_page: 100,
            });

            const marker = '<!-- pr-maintenance:missing-closing-keyword -->';
            const alreadyCommented = comments.some(c => (c.body || '').includes(marker));
            if (alreadyCommented) return;

            const msg = `${marker}\nHi @${pr.user.login} — please add a closing keyword to the PR description so the linked issue closes on merge.\n\nExamples: Fixes #123 · Closes owner/repo#123 · Resolves https://github.com/${context.repo.owner}/${context.repo.repo}/issues/123`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: msg,
            });

  auto_close_stale_failing_prs:
    name: Close stale failing PRs
    if: ${{ github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    steps:
      - name: Close stale failing PRs
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const thresholdDays = parseInt(process.env.THRESHOLD_DAYS || '5', 10);
            const now = new Date();

            async function listAllOpenPRs() {
              const prs = [];
              for await (const response of github.paginate.iterator(github.rest.pulls.list, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100,
              })) {
                prs.push(...response.data);
              }
              return prs;
            }

            function daysBetween(a, b) {
              const ms = Math.abs(a.getTime() - b.getTime());
              return ms / (1000 * 60 * 60 * 24);
            }

            async function latestCommitDate(owner, repo, sha) {
              const { data: commit } = await github.rest.repos.getCommit({ owner, repo, ref: sha });
              // Prefer committer date; fall back to author
              const when = commit.commit.committer?.date || commit.commit.author?.date || commit.committer?.date || commit.author?.date;
              return new Date(when);
            }

            async function hasSuccessfulChecks(owner, repo, sha) {
              // Determine success if ALL GitHub Actions check runs on this ref concluded successfully
              try {
                const { data: runs } = await github.rest.checks.listForRef({ owner, repo, ref: sha, per_page: 100 });
                const ghaRuns = runs.check_runs?.filter(r => r.app?.slug === 'github-actions') || [];
                if (ghaRuns.length > 0 && ghaRuns.every(r => r.conclusion === 'success')) {
                  return true;
                }
              } catch (e) {
                core.warning(`checks.listForRef failed: ${e.message}`);
              }

              // Also check Actions workflow runs for the commit
              try {
                const { data } = await github.rest.actions.listWorkflowRunsForCommit({ owner, repo, commit_sha: sha, per_page: 100 });
                const runs = data.workflow_runs || [];
                if (runs.length > 0 && runs.every(r => r.conclusion === 'success')) {
                  return true;
                }
              } catch (e) {
                core.warning(`actions.listWorkflowRunsForCommit failed: ${e.message}`);
              }

              // Fallback to check suites (success indicates all runs in the suite succeeded)
              try {
                const { data: suites } = await github.rest.checks.listSuitesForRef({ owner, repo, ref: sha, per_page: 100 });
                const ghaSuites = suites.check_suites?.filter(s => s.app?.slug === 'github-actions') || [];
                if (ghaSuites.length > 0 && ghaSuites.every(s => s.conclusion === 'success')) {
                  return true;
                }
              } catch (e) {
                core.warning(`checks.listSuitesForRef failed: ${e.message}`);
              }

              // Legacy statuses combined API
              try {
                const { data: combined } = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: sha });
                if (combined.state === 'success') return true;
              } catch (e) {
                core.warning(`repos.getCombinedStatusForRef failed: ${e.message}`);
              }

              return false;
            }

            // label to ignore auto-close if maintainers set it
            const IGNORE_LABEL = 'do-not-autoclose';

            // Check if opt-out label exists (do not auto-create)
            try {
              await github.rest.issues.getLabel({ owner: context.repo.owner, repo: context.repo.repo, name: IGNORE_LABEL });
            } catch (e) {
              if (e.status !== 404) core.warning(`Label check failed: ${e.message}`);
            }

            const prs = await listAllOpenPRs();

            for (const pr of prs) {
              try {
                if (pr.draft) continue;
                if (Array.isArray(pr.labels) && pr.labels.some(l => (l.name || '').toLowerCase() === IGNORE_LABEL)) continue;

                const head = pr.head;
                const sha = head?.sha;
                if (!sha) continue;

                const owner = context.repo.owner;
                const repo = context.repo.repo;

                const commitDate = await latestCommitDate(owner, repo, sha);
                const ageDays = daysBetween(now, commitDate);
                const success = await hasSuccessfulChecks(owner, repo, sha);

                if (!success && ageDays >= thresholdDays) {
                  const closeMessage = `Closing as the latest commit (sha: ${sha.slice(0,7)}) hasn't had a successful build for over ${thresholdDays} days. Push a new commit to rerun CI and re-open if needed.`;
                  // Leave a comment before closing
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: pr.number,
                    body: closeMessage,
                  });

                  await github.rest.pulls.update({
                    owner,
                    repo,
                    pull_number: pr.number,
                    state: 'closed',
                  });
                }
              } catch (e) {
                core.warning(`Failed processing PR #${pr.number}: ${e.message}`);
              }
            }
